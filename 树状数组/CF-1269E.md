# Codeforces-1269E

## 题意

给定1～n数字的permutation，记经过相邻交换操作的次数后数列中包含1～k的最少次数为f(k),现在要求出f(1)~f(n)

## 分析

1.使用BIT记录位置数组求逆序对

2.计算将无关数组移出数组需要的步骤数

自然是找到数列的中间位置，左边的移动到左边，右边的移动到右边话费的步骤的最少的，所以这里使用**二分**已知数字个数反求位置。

怎样计算中间某位置向一边需要移动的次数呢？

我们可以举个例子计算，|5_4__1,其移动次数为1+3 == 4，于是我们就努力使用数字的下标构造一下！

为什么要这样计算？（答案已经出来了）

因为在要让数组中出现1～k，其中可能会包含1～k之外的数字，我们要将这些数字移出去，那么问题就变成如何计算了。

经过观察我们发现其与周围数字的下标有些关系，于是我们同时维护一个位置真值BIT（与打1BIT类似）

## 总结

通过本题我们发现BIT时常与二分（反求位置）、真值BIT相结合，对于一些有BIT影子的题目要努力往以上方面考虑一下。
