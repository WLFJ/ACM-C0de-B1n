#Codeforces-1284B

## 题意

给定一些串，在其中放回先后选择两个串，将其拼接出一个新的串，统计其中包含正序对的新串个数。

## 分析

存在正序对是比较复杂的，应为我们要检查其中的每一对。

我们能否考虑其补集呢——在全部情况中排除不满足条件的串。

全部选择方案有$$n ^ 2$$种。

不满足情况的串就很规则了：有且只有非增串。当然这是拼接之后的结果，显然我们知道，如果两个字串是非增的，并且在凭借时候串A的最后一个元素大于等于串B的第一个元素就是的所有组合都是不满足情况的。

计数不满足串的过程很有意思，只需要将所有非增串的最后一个数字排序，然后拿上每一个非增串的开头去搜索计数就好了。

## 收获

在代码实现上我学习到了以下技巧：

× 检查是否为非增串？

首先将输入的串reverse(begin, end)，将其反转

时候使用'is_sorted(begin, end)'判断是否为递增哦排序的

× 维护pair的vector技巧

使用'emplace_back(elem1, elem2)'方便插入二元组而不需要加其他东西

× 活用'upper_bound'和'lower_bound'

在搜索之后可以任意计算区间长度：'ans -= v.end() - lower_bound(v.begin(), v.end(), PII(a.second, 0));'

